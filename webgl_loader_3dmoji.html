<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - glTF loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="omggif.js"></script>
		<script src="CCapture.all.min.js"></script>

		<style>

        body {
            margin: 0;
            overflow: hidden;
        }

        .full-screen {
              position: absolute;
              left: 0;
              right: 0;
              top: 0;
              bottom: 0;
              background-color: green;
        }
    </style>

	</head>

	<body>
		<canvas id="canvas"></canvas><br/><br/>
		<script type="module">

			import * as THREE from './three.module.js';

			import { OrbitControls } from './OrbitControls.js';
			import { GLTFLoader } from './GLTFLoader.js';
			import { FBXLoader } from './FBXLoader.js'
			import { RGBELoader } from './RGBELoader.js';
			import { RoughnessMipmapper } from './RoughnessMipmapper.js';
			import { GUI } from './dat.gui.module.js';


			let camera, scene, renderer, hikemoji3d, mixer, container, capturer;
			const clock = new THREE.Clock();


			init();

			capturer.start();
			animate();

			function initLights() {
				var camera_global = (-0.09983361, 0.5368214, -0.9119075)
				// camera_global = (0, 0, 0)

				const filler_left = new THREE.PointLight( 0xE1EFFF, 0.1, 13.65 );
				filler_left.position.set( -0.3 + camera_global[0], -0.35 + camera_global[1], 1.04 + camera_global[2] );
				filler_left.rotation.set(25.08, 154, 10.3);
				scene.add( filler_left );

				const filler_right = new THREE.PointLight( 0xE1EFFF, 0.1, 13.65 );
				filler_right.position.set( 0.78 + camera_global[0], -0.35 + camera_global[1], 1.04 + camera_global[2] );
				filler_right.rotation.set(25.08, 154, 10.3);
				scene.add( filler_right );

				const filler_up = new THREE.PointLight( 0xE1EFFF, 0.1, 13.65 );
				filler_up.position.set( 0.232 + camera_global[0], 0.3 + camera_global[1], 1.18 + camera_global[2] );
				filler_up.rotation.set(25.08, 154, 10.3);
				scene.add( filler_up );

				const key_center = new THREE.DirectionalLight( 0xffffff, 0.99 );
				key_center.position.set(0.194 + camera_global[0], -0.72 + camera_global[1], 3.251 + camera_global[2]);
				key_center.rotation.set(-0.04, -180, 39.5);
				scene.add( key_center );

				const light = new THREE.AmbientLight( 0xffffff ); // soft white light
				scene.add( light );
			}

			function initHikeMojiModel() {
				const loader = new GLTFLoader().setPath( 'models/gltf/MaleLODA_Rig_V02_Flip_out/' );
				loader.load( 'MaleLODA_Rig_V02_Flip.gltf', function ( gltf ) {

					hikemoji3d = gltf;
					hikemoji3d.scene.children[0].children[0].position.set(0.14, -0.705, 0);
					hikemoji3d.scene.children[0].children[0].scale.set(0.53, 0.53, 0.53);
					
					var moji_scene = gltf.scene;
					moji_scene.traverse((child) => {
					  if (! child.isMesh) return;
					  var prevMaterial = child.material;
					  child.material = new THREE.MeshPhongMaterial();
					  THREE.MeshStandardMaterial.prototype.copy.call( child.material, prevMaterial );
					});
					moji_scene.traverse(node => {
						if(node.isMesh) {
							console.log("traversing node ", node);
							node.castShadow = false;
							node.material.shininess=1000
							node.material.metalness=1.5
						}
					});

					mixer = new THREE.AnimationMixer(moji_scene);

					var action = mixer.clipAction( gltf.animations[0] );
					// action.setLoop(THREE.LoopOnce);
					// action.clampWhenFinished = true;
					action.enable = true;
					action.play();

					console.log("gltf.animations: ", gltf.animations);

					scene.add( moji_scene );
					console.log('Hikemoji model loaded in', clock.getElapsedTime());
					render(0);
					console.log('Hikemoji model loaded in', clock.getElapsedTime());
				} );
			}

			function initRenderer() {
				renderer = new THREE.WebGLRenderer( { canvas: canvas, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				container.appendChild( renderer.domElement );
			}

			function initCamera() {
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( 0.1, 0.1, 1.88 );
				camera.rotation.set( 0, -180, 0);
				camera.fov = 47;
			}

			function initFloor() {
				var geometry = new THREE.PlaneGeometry( 1000, 1000);
				var material = new THREE.MeshPhongMaterial( { color: 0x111111 } );
				var floor = new THREE.Mesh( geometry, material );
				floor.position.y = -0.705;
				floor.rotateX( - Math.PI / 2);
				scene.add( floor );
				console.log('floor position:', floor.position);
			}

			function initCapturer() {
				capturer = new CCapture( { 
					format: 'webm',
					framerate: 60,
					verbose: true,
					timeLimit: 6
				} );
			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();
				scene.background = null;

				const canvas = document.getElementById( 'canvas' );
				initRenderer();
				initCamera();
				initLights();
				initCapturer();
				initHikeMojiModel();
				initFloor();

				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				pmremGenerator.compileEquirectangularShader();

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.target.set( 0, 0, -0.2);
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame(animate);

				const delta = clock.getDelta();
				render(delta);
				if(mixer) mixer.update(delta);
			}

			function render(progress) {
				// if(hikemoji3d) {
				// 	hikemoji3d.scene.rotation.y += progress;
				// }
				renderer.render( scene, camera );
				capturer.capture( canvas );
				// console.log("Ran in ", clock.getElapsedTime(), 'time')
			}

		</script>

	</body>
</html>
